#include "CmdLineParser.h"
#include "SoundFontFormat.h"
#include "WaveFileFormat.h"
#include "WaveForm.h"
#include "Main.h"
#include <memory>
#include <filesystem>

using namespace AudioDataLib;

int main(int argc, char** argv)
{
	CmdLineParser parser;
	parser.SetSynopsis("This is just a basic command-line tool meant to exercise the AudioDataLib shared library.");

	parser.RegisterArg("play", 1, "Play the given file.  This can be a WAV or MIDI file.");
	parser.RegisterArg("keyboard", 1, "Receive MIDI input from the given MIDI keyboard device.");
	parser.RegisterArg("synth", 0, "Synthesize MIDI input to the sound-card.");
	parser.RegisterArg("record_midi", 1, "Record MIDI input to the given MIDI file.");
	parser.RegisterArg("log_midi", 0, "Print MIDI input to the screen as it is given.");
	parser.RegisterArg("record_wave", 1, "Record microphone input to the given WAV file.");
	parser.RegisterArg("record_dev", 1, "Record the output being generated by an audio device into the given WAV file.");
	parser.RegisterArg("mix", 3, "Mix the two given WAV files into a single WAV file, the third given output file.");
	parser.RegisterArg("concat", 3, "Concatinate the two given WAV files into a single WAV file, the third given output file.");
	parser.RegisterArg("trim_start", 2, "Trim the start of the given WAV file by the given number of seconds.  This modifies the given file.");
	parser.RegisterArg("trim_end", 2, "Truncate the given WAV file by the given number of seconds.  This modifies the given file.");
	parser.RegisterArg("help", 0, "Show the usage.");
	parser.RegisterArg("dump_info", 1, "Load the given file and then dump some stats about it.");
	parser.RegisterArg("unpack", 1, "Unpack the given sound-font file by generating from it a bunch of WAV files for all the samples it contains.");
	parser.RegisterArg("test", 0, "Run some test code.");
	
	std::string error;
	if (!parser.Parse(argc, argv, error))
	{
		fprintf(stderr, ("Error: " + error).c_str());
		parser.PrintUsage(stderr);
		return -1;
	}

	if (parser.ArgGiven("help"))
	{
		parser.PrintUsage(stdout);
		return 0;
	}

	if (parser.ArgGiven("test"))
	{
		RunTest();
		return 0;
	}

	if (parser.ArgGiven("dump_info"))
	{
		const std::string& filePath = parser.GetArgValue("dump_info", 0);

		Error error;
		if (!DumpInfo(filePath, error))
		{
			fprintf(stderr, error.GetMessage().c_str());
			return -1;
		}

		return 0;
	}
	
	if (parser.ArgGiven("unpack"))
	{
		const std::string& filePath = parser.GetArgValue("unpack", 0);
		Error error;
		if (!UnpackSoundFont(filePath, error))
		{
			fprintf(stderr, "Failed to unpack sound font...\n\n%s", error.GetMessage().c_str());
			return -1;
		}

		return 0;
	}

	if (parser.ArgGiven("play"))
	{
		const std::string& filePath = parser.GetArgValue("play", 0);
		FileFormat* fileFormat = FileFormat::CreateForFile(filePath);
		if (!fileFormat)
		{
			fprintf(stderr, "File format for file \"%s\" not recognized.", filePath.c_str());
			return -1;
		}

		FileInputStream inputStream(filePath.c_str());
		if (!inputStream.IsOpen())
		{
			fprintf(stderr, "Could not open file: %s", filePath.c_str());
			delete fileFormat;
			return -1;
		}

		Error error;
		FileData* fileData = nullptr;
		if (!fileFormat->ReadFromStream(inputStream, fileData, error))
		{
			fprintf(stderr, ("Error: " + error.GetMessage()).c_str());
			delete fileFormat;
			return -1;
		}

		int retCode = 0;

		auto midiData = dynamic_cast<MidiData*>(fileData);
		auto audioData = dynamic_cast<AudioData*>(fileData);

		if (midiData)
		{
			if (!PlayMidiData(midiData, error))
				retCode = -1;
		}
		else if (audioData)
		{
			if (!PlayAudioData(audioData, error))
				retCode = -1;
		}
		else
		{
			error.Add("Failed to cast file data!");
			retCode = -1;
		}

		if (error)
			fprintf(stderr, "Error: %s", error.GetMessage().c_str());

		delete fileData;
		delete fileFormat;
		return retCode;
	}
	
	if (parser.ArgGiven("mix"))
	{
		std::string sourceFileA = parser.GetArgValue("mix", 0);
		std::string sourceFileB = parser.GetArgValue("mix", 1);
		std::string destinationFile = parser.GetArgValue("mix", 2);

		Error error;
		if (!MixAudio({ sourceFileA, sourceFileB }, destinationFile, error))
		{
			fprintf(stderr, "Error: %s", error.GetMessage().c_str());
			return -1;
		}

		return 0;
	}

	fprintf(stderr, "Features not yet implimented for given arguments.  Sorry, bro.\n");
	return -1;
}

void RunTest()
{
	WaveForm waveForm;

	uint32_t numSamples = 4096;
	double frequencyHz = 1.0; //440.0;
	double durationSeconds = 2.0;

	for (uint32_t i = 0; i < numSamples; i++)
	{
		WaveForm::Sample sample;

		sample.timeSeconds = (double(i) / double(numSamples - 1)) * durationSeconds;
		sample.amplitude = ::sin(2.0 * ADL_PI * sample.timeSeconds * frequencyHz);

		waveForm.AddSample(sample);
	}

	std::list<double> dominantFrequenciesList;
	Error error;
	waveForm.CalcDominantFrequencies(dominantFrequenciesList, 1, error);

	double dominantFrequency = *dominantFrequenciesList.begin();
	printf("Dominant frequency: %f\n", dominantFrequency);
}

bool PlayMidiData(AudioDataLib::MidiData* midiData, AudioDataLib::Error& error)
{
	SystemClockTimer timer;
	RtMidiPlayer player(&timer);

	player.SetMidiData(midiData);
	std::set<uint32_t> playableTrackSet;

	player.GetSimultaneouslyPlayableTracks(playableTrackSet);
	player.SetTimeSeconds(0.0);
	if (!player.BeginPlayback(playableTrackSet, error))
		return false;

	while (!player.NoMoreToPlay())
	{
		if (!player.ManagePlayback(error))
			return false;

		// TODO: Maybe watch for key-presses here?  Should be able to pause, rewind, fastforward, and just stop.
		// TODO: Print playback time periodically, but can you do it without introducing a newline each time?
	}

	if (!player.EndPlayback(error))
		return false;

	return true;
}

bool PlayAudioData(AudioDataLib::AudioData* audioData, AudioDataLib::Error& error)
{
	bool success = false;
	SDLAudioPlayer player;

	do
	{
		if (!player.Setup(error))
			break;

		if (!player.PlayAudio(audioData, error))
			break;

		while (player.IsPlayingSomething())
		{
			if (!player.ManagePlayback(error))
				break;

			// TODO: Maybe listen for key-presses here and let the user quit if desired?
		}

		if (error)
			break;

		success = true;
	} while (false);
	
	player.Shutdown(error);

	return success;
}

bool MixAudio(const std::vector<std::string>& sourceFileArray, const std::string& destinationFile, AudioDataLib::Error& error)
{
	bool success = false;

	std::vector<FileFormat*> fileFormatArray;
	std::vector<FileData*> fileDataArray;

	FileFormat* fileFormatOut = nullptr;

	do
	{
		for (const std::string& sourceFile : sourceFileArray)
		{
			FileFormat* fileFormat = FileFormat::CreateForFile(sourceFile);
			if (!fileFormat)
			{
				error.Add("Did not recognize file type for file: " + sourceFile);
				break;
			}

			fileFormatArray.push_back(fileFormat);
		}

		if (fileFormatArray.size() != sourceFileArray.size())
		{
			error.Add("Could not recognize all source file type.");
			break;
		}

		for (int i = 0; i < (signed)sourceFileArray.size(); i++)
		{
			FileFormat* fileFormat = fileFormatArray[i];
			const std::string& sourceFile = sourceFileArray[i];

			FileInputStream inputStream(sourceFile.c_str());
			if (!inputStream.IsOpen())
			{
				error.Add(FormatString("Failed to open file %s for reading.", sourceFile.c_str()));
				break;
			}

			FileData* fileData = nullptr;
			if (!fileFormat->ReadFromStream(inputStream, fileData, error))
			{
				error.Add("Failed to read file: " + sourceFile);
				break;
			}

			fileDataArray.push_back(fileData);

			if (!dynamic_cast<AudioData*>(fileData))
			{
				error.Add(FormatString("File data for file %s is not audio data.", sourceFile.c_str()));
				break;
			}
		}

		if (fileDataArray.size() != sourceFileArray.size())
		{
			error.Add("Could not load all source files.");
			break;
		}

		AudioSink audioSink(true);

		AudioData::Format format;
		format.bitsPerSample = 0;

		double maxTimeSeconds = 0.0;
		for (FileData* fileData : fileDataArray)
		{
			auto audioData = dynamic_cast<AudioData*>(fileData);
			double timeSeconds = audioData->GetTimeSeconds();
			if (maxTimeSeconds < timeSeconds)
				maxTimeSeconds = timeSeconds;

			audioSink.AddAudioInput(new AudioStream(audioData));

			if (format.bitsPerSample == 0)
				format = audioData->GetFormat();
		}

		auto audioStreamOut = new AudioStream(format);
		audioSink.SetAudioOutput(audioStreamOut);
		audioSink.GenerateAudio(maxTimeSeconds, 0.0);

		AudioData generatedAudioData;
		generatedAudioData.GetFormat() = audioStreamOut->GetFormat();
		generatedAudioData.SetAudioBufferSize(audioStreamOut->GetSize());
		audioStreamOut->ReadBytesFromStream(generatedAudioData.GetAudioBuffer(), generatedAudioData.GetAudioBufferSize());

		fileFormatOut = FileFormat::CreateForFile(destinationFile);
		if (!fileFormatOut)
		{
			error.Add("Could not recognize file type for file: " + destinationFile);
			break;
		}

		FileOutputStream outputStream(destinationFile.c_str());
		if (!outputStream.IsOpen())
		{
			error.Add(FormatString("Could not open file %s for writing.", destinationFile.c_str()));
			break;
		}

		if (!fileFormatOut->WriteToStream(outputStream, &generatedAudioData, error))
		{
			error.Add("Failed to write file: " + destinationFile);
			break;
		}

		success = true;
	} while (false);

	for (FileFormat* fileFormat : fileFormatArray)
		delete fileFormat;

	for (FileData* fileData : fileDataArray)
		delete fileData;

	delete fileFormatOut;

	return success;
}

bool DumpInfo(const std::string& filePath, AudioDataLib::Error& error)
{
	bool success = false;
	FileFormat* fileFormat = nullptr;
	FileData* fileData = nullptr;

	do
	{
		FileInputStream inputStream(filePath.c_str());
		if (!inputStream.IsOpen())
		{
			error.Add("Failed to open file: " + filePath);
			break;
		}

		fileFormat = FileFormat::CreateForFile(filePath.c_str());
		if (!fileFormat)
		{
			error.Add("Failed type not recognized for file: " + filePath);
			break;
		}

		if (!fileFormat->ReadFromStream(inputStream, fileData, error))
		{
			error.Add("Failed to read file: " + filePath);
			break;
		}

		fileData->DumpInfo(stdout);

		success = true;
	} while (false);

	delete fileFormat;
	delete fileData;

	return success;
}

bool UnpackSoundFont(const std::string& filePath, AudioDataLib::Error& error)
{
	bool success = false;
	FileFormat* fileFormat = nullptr;
	FileData* fileData = nullptr;

	do
	{
		fileFormat = FileFormat::CreateForFile(filePath);
		if (!fileFormat)
		{
			error.Add("Could not recognize file type: " + filePath);
			break;
		}

		auto soundFontFormat = dynamic_cast<SoundFontFormat*>(fileFormat);
		if (!soundFontFormat)
		{
			error.Add("Not given a sound-font file: " + filePath);
			break;
		}

		FileInputStream inputStream(filePath.c_str());
		if (!inputStream.IsOpen())
		{
			error.Add("Failed to open file: " + filePath);
			break;
		}

		if (!soundFontFormat->ReadFromStream(inputStream, fileData, error))
		{
			error.Add("Failed to read file: " + filePath);
			break;
		}

		auto soundFontData = dynamic_cast<SoundFontData*>(fileData);
		if (!soundFontData)
		{
			error.Add("Didn't get sound font data!");
			break;
		}

		if (soundFontData->GetNumPitchDatas() == 0)
		{
			error.Add("No pitch datas found in the sound font data!");
			break;
		}

		WaveFileFormat waveFileFormat;

		for (uint32_t i = 0; i < soundFontData->GetNumPitchDatas(); i++)
		{
			const SoundFontData::PitchData* pitchData = soundFontData->GetPitchData(i);
			
			for (uint32_t j = 0; j < pitchData->GetNumLoopedAudioDatas(); j++)
			{
				const SoundFontData::LoopedAudioData* audioData = pitchData->GetLoopedAudioData(j);

				std::string sampleFilePath = (std::filesystem::path(filePath).parent_path() / std::filesystem::path(filePath).stem()).string();
				sampleFilePath += "__" + audioData->GetName();
				sampleFilePath += ".wav";

				std::replace(sampleFilePath.begin(), sampleFilePath.end(), ' ', '_');
				std::replace(sampleFilePath.begin(), sampleFilePath.end(), '|', '_');
				std::replace(sampleFilePath.begin(), sampleFilePath.end(), '(', '_');
				std::replace(sampleFilePath.begin(), sampleFilePath.end(), ')', '_');
				std::replace(sampleFilePath.begin(), sampleFilePath.end(), '#', 's');

				FileOutputStream outputStream(sampleFilePath.c_str());
				if (!outputStream.IsOpen())
				{
					error.Add(FormatString("Failed to open file %s for writing.", sampleFilePath.c_str()));
					break;
				}

				if (!waveFileFormat.WriteToStream(outputStream, audioData, error))
					break;
			}

			if (error)
				break;
		}

		if (error)
			break;

		success = true;
	} while (false);

	delete fileFormat;
	delete fileData;

	return success;
}