#pragma once

#include "Common.h"
#include "ByteStream.h"

namespace AudioDataLib
{
	// What this class is trying to be is a general purpose way of mixing and/or converting audio.
	// It can be used for synthesis or real-time purposes.  Note that to use this class in a
	// thread-safe manner, you should use the ThreadSafeAudioStream class instead of just the
	// regular AudioStream class for the audio output.
	class AUDIO_DATA_LIB_API AudioSink
	{
	public:
		AudioSink();
		virtual ~AudioSink();

		void Clear();

		// Make sure that an amount of audio data equivilant to the given amount
		// of time is available for consumption in our audio output stream.
		// This will produce silence in the audio output if necessary.  Note that
		// too much buffered time will create latency when new audio clips are fired.
		// But too little buffered can cause audio drop-outs due to a starved device.
		void GenerateAudio(double desiredSecondsAvailable, double minSecondsAddedPerMix);
	
		// The memory for the given audio stream is deleted once it has been depleted.
		void AddAudioInput(std::shared_ptr<AudioStream> audioStream);

		// Give access to the audio stream generated by this class.
		std::shared_ptr<AudioStream> GetAudioOutput() { return *this->audioStreamOut; }
		void SetAudioOutput(std::shared_ptr<AudioStream> audioStreamOut);

		// Remember that this count decrements as the audio inputs are depleted.
		uint32_t GetAudioInputCount() const { return (uint32_t)this->audioStreamInArray->size(); }

	protected:

		// TODO: Byte swapping?
		template<typename T>
		T CalcNetSample()
		{
			int64_t netSampleWide = 0;

			for (auto& audioStreamIn : *this->audioStreamInArray)
			{
				T sampleNarrow = 0;
				if (audioStreamIn->ReadType<T>(&sampleNarrow))
					netSampleWide += int64_t(sampleNarrow);
			}

			constexpr int64_t minSample = std::numeric_limits<T>::min();
			constexpr int64_t maxSample = std::numeric_limits<T>::max();
			
			if (netSampleWide > maxSample)
				netSampleWide = maxSample;
			if (netSampleWide < minSample)
				netSampleWide = minSample;

			T netSampleNarrow = T(netSampleWide);
			return netSampleNarrow;
		}

		// TODO: Byte swapping?
		template<>
		float CalcNetSample()
		{
			double netSampleWide = 0.0;

			for (auto& audioStreamIn : *this->audioStreamInArray)
			{
				float sampleNarrow = 0.0f;
				if (audioStreamIn->ReadType<float>(&sampleNarrow))
					netSampleWide += double(sampleNarrow);
			}

			netSampleWide = ADL_CLAMP(netSampleWide, -1.0, 1.0);
			float netSampleNarrow = float(netSampleWide);
			return netSampleNarrow;
		}

		// TODO: Byte swapping?
		template<>
		double CalcNetSample()
		{
			double netSample = 0.0;
			double sample = 0.0;
			for(auto& audioStreamIn : *this->audioStreamInArray)
				if (audioStreamIn->ReadType<double>(&sample))
					netSample += sample;

			netSample = ADL_CLAMP(netSample, -1.0, 1.0);
			return netSample;
		}

		std::vector<std::shared_ptr<AudioStream>>* audioStreamInArray;
		std::shared_ptr<AudioStream>* audioStreamOut;
	};
}