#pragma once

#include "AudioCommon.h"
#include "ByteStream.h"

namespace AudioDataLib
{
	// What this class is trying to be is a general purpose way of mixing and/or converting audio.
	// It can be used for synthesis or real-time purposes.
	// TODO: Add locking support.  It's best to add locking support at this level, because we can
	//       make the mutex locks as tight as possible.
	class AUDIO_DATA_LIB_API AudioSink
	{
	public:
		AudioSink();
		virtual ~AudioSink();

		void Clear();

		// Make sure that an amount of audio data equivilant to the given amount
		// of time is available for consumption in our audio output stream.
		// This will produce silence in the audio output if necessary.
		void MixAudio(double desiredSecondsAvailable, double minSecondsAddedPerMix);
	
		// The memory for the given audio stream is deleted once it has been depleted.
		void AddAudioInput(AudioStream* audioStream);

		// Give access to the audio stream generated by this class.
		AudioStream* GetAudioOutput() { return this->audioStreamOut; }
		void SetAudioOutput(AudioStream* audioStreamOut);

		// Remember that this count decrements as the audio inputs are depleted.
		int GetAudioInputCount() const { return this->audioStreamInArray->size(); }

	protected:

		template<typename T>
		T CalcNetSample()
		{
			int64_t netSampleWide = 0;

			for (AudioStream* audioStreamIn : *this->audioStreamInArray)
			{
				T sampleNarrow = 0;
				if (audioStreamIn->ReadType<T>(&sampleNarrow))
					netSampleWide += int64_t(sampleNarrow);
			}

			constexpr int64_t minSample = std::numeric_limits<T>::min();
			constexpr int64_t maxSample = std::numeric_limits<T>::max();
			
			if (netSampleWide > maxSample)
				netSampleWide = maxSample;
			if (netSampleWide < minSample)
				netSampleWide = minSample;

			T netSampleNarrow = T(netSampleWide);
			return netSampleNarrow;
		}

		std::vector<AudioStream*>* audioStreamInArray;
		AudioStream* audioStreamOut;
	};
}