#include "AudioSink.h"
#include "CmdLineParser.h"
#include "SoundFontFormat.h"
#include "WaveFileFormat.h"
#include "WaveForm.h"
#include "Main.h"
#include "MidiPortSource.h"
#include "MidiPortDestination.h"
#include "MidiDebugSource.h"
#include "MidiMsgLogDestination.h"
#include "MidiMsgRecorderDestination.h"
#include "MidiFileFormat.h"
#include "MidiPlayer.h"
#include "Keyboard.h"
#include "Mutex.h"
#include "SimpleSynth.h"
#include "SampleBasedSynth.h"
#include "LoopedAudioModule.h"
#include "ReverbModule.h"
#include <memory>
#include <filesystem>

using namespace AudioDataLib;

int main(int argc, char** argv)
{
	CmdLineParser parser;
	parser.SetSynopsis("This is just a basic command-line tool meant to exercise the AudioDataLib shared library.");

	parser.RegisterArg("play", 1, "Play the given file.  This can be a WAV or MIDI file.");
	parser.RegisterArg("keyboard", 1, "Receive MIDI input from the given MIDI input port.  A MIDI keyboard is not necessarily connected to the port, but could be any MIDI device.");
	parser.RegisterArg("synth", 1, "Synthesize MIDI input to the sound-card.  Use the given synth type: \"simple\", or \"sample\".");
	parser.RegisterArg("soundfont", 2, "If using the \"sample\" synth, use this option to specify the sound-font to use on the given instrument [1, 128].");
	parser.RegisterArg("record_midi", 1, "Record MIDI input to the given MIDI file.");
	parser.RegisterArg("record_wave", 1, "Record synthesized MIDI input to the given WAVE file.");
	parser.RegisterArg("log_midi", 0, "Print MIDI input to the screen as it is given.");
	parser.RegisterArg("record_wave", 1, "Record microphone input to the given WAV file.");
	parser.RegisterArg("record_dev", 1, "Record the output being generated by an audio device into the given WAV file.  This is one way to convert a MIDI file into a WAV file, if the MIDI file is playing.");
	parser.RegisterArg("mix", 3, "Mix the two given WAV files into a single WAV file, the third given output file.");
	parser.RegisterArg("concat", 3, "Concatinate the two given WAV files into a single WAV file, the third given output file.");
	parser.RegisterArg("trim_start", 2, "Trim the start of the given WAV file by the given number of seconds.  This modifies the given file.");
	parser.RegisterArg("trim_end", 2, "Truncate the given WAV file by the given number of seconds.  This modifies the given file.");
	parser.RegisterArg("help", 0, "Show the usage.");
	parser.RegisterArg("dump_info", 1, "Load the given file and then dump some stats about it.");
	parser.RegisterArg("dump_csv", 1, "Load the given file and then use it to dump a CSV to disk.");
	parser.RegisterArg("unpack", 1, "Unpack the given sound-font file by generating from it a bunch of WAV files for all the samples it contains.");
	parser.RegisterArg("device_substr", 1, "Specify a sub-string to look for when trying to select an audio device for input or output.");
	parser.RegisterArg("add_reverb", 2, "Add a reverb effect to the given WAV file.");
	
	std::string error;
	if (!parser.Parse(argc, argv, error))
	{
		if (error.length() > 0)
		{
			fprintf(stderr, ("Error: " + error).c_str());
			fprintf(stderr, "\n\n");
		}

		parser.PrintUsage(stderr);
		return -1;
	}

	if (parser.ArgGiven("help"))
	{
		parser.PrintUsage(stdout);
		return 0;
	}

	if (parser.ArgGiven("dump_info") || parser.ArgGiven("dump_csv"))
	{
		std::string filePath;

		if (parser.ArgGiven("dump_info"))
			filePath = parser.GetArgValue("dump_info", 0);
		else
			filePath = parser.GetArgValue("dump_csv", 0);

		Error error;
		if (!DumpInfo(filePath, parser.ArgGiven("dump_csv"), error))
		{
			fprintf(stderr, error.GetErrorMessage().c_str());
			return -1;
		}

		return 0;
	}
	
	if (parser.ArgGiven("unpack"))
	{
		const std::string& filePath = parser.GetArgValue("unpack", 0);
		Error error;
		if (!UnpackSoundFont(filePath, error))
		{
			fprintf(stderr, "Failed to unpack sound font...\n\n%s\n", error.GetErrorMessage().c_str());
			return -1;
		}

		return 0;
	}

	if (parser.ArgGiven("add_reverb"))
	{
		const std::string& inFilePath = parser.GetArgValue("add_reverb", 0);
		const std::string& outFilePath = parser.GetArgValue("add_reverb", 1);
		Error error;
		if (!AddReverb(inFilePath, outFilePath, error))
		{
			fprintf(stderr, error.GetErrorMessage().c_str());
			return -1;
		}

		return 0;
	}

	if (parser.ArgGiven("play"))
	{
		const std::string& filePath = parser.GetArgValue("play", 0);
		std::shared_ptr<FileFormat> fileFormat = FileFormat::CreateForFile(filePath);
		if (!fileFormat.get())
		{
			fprintf(stderr, "File format for file \"%s\" not recognized.\n", filePath.c_str());
			return -1;
		}

		FileInputStream inputStream(filePath.c_str());
		if (!inputStream.IsOpen())
		{
			fprintf(stderr, "Could not open file: %s\n", filePath.c_str());
			return -1;
		}

		Error error;
		FileData* fileData = nullptr;
		if (!fileFormat->ReadFromStream(inputStream, fileData, error))
		{
			fprintf(stderr, ("Error: " + error.GetErrorMessage()).c_str());
			return -1;
		}

		int retCode = 0;

		std::shared_ptr<MidiData> midiData(dynamic_cast<MidiData*>(fileData));
		std::shared_ptr<AudioData> audioData(dynamic_cast<AudioData*>(fileData));

		if (midiData.get())
		{
			if (!PlayMidiData(midiData.get(), error))
				retCode = -1;
		}
		else if (audioData.get())
		{
			if (!PlayAudioData(audioData.get(), parser, error))
				retCode = -1;
		}
		else
		{
			error.Add("Failed to cast file data!");
			delete fileData;
			retCode = -1;
		}

		if (error)
			fprintf(stderr, "Error: %s\n", error.GetErrorMessage().c_str());

		return retCode;
	}
	
	if (parser.ArgGiven("mix"))
	{
		std::string sourceFileA = parser.GetArgValue("mix", 0);
		std::string sourceFileB = parser.GetArgValue("mix", 1);
		std::string destinationFile = parser.GetArgValue("mix", 2);

		Error error;
		if (!MixAudio({ sourceFileA, sourceFileB }, destinationFile, error))
		{
			fprintf(stderr, "Error: %s\n", error.GetErrorMessage().c_str());
			return -1;
		}

		return 0;
	}

	if (parser.ArgGiven("keyboard"))
	{
		Error error;
		if (!PlayWithKeyboard(parser, error))
		{
			if(error)
				fprintf(stderr, "Error: %s\n", error.GetErrorMessage().c_str());
			return -1;
		}

		return 0;
	}

	fprintf(stderr, "Features not yet implimented for given arguments.  Sorry, bro.\n");
	return -1;
}

bool AddReverb(const std::string& inFilePath, const std::string& outFilePath, AudioDataLib::Error& error)
{
	std::shared_ptr<FileFormat> fileFormat = FileFormat::CreateForFile(inFilePath);
	if (!fileFormat)
	{
		error.Add("Could not recognize file: " + inFilePath);
		return false;
	}

	FileInputStream inputStream(inFilePath.c_str());
	if (!inputStream.IsOpen())
	{
		error.Add("Failed to open file: " + inFilePath);
		return false;
	}

	FileData* fileData = nullptr;
	if (!fileFormat->ReadFromStream(inputStream, fileData, error))
	{
		error.Add("Failed to read file: " + inFilePath);
		return false;
	}

	std::shared_ptr<AudioData> audioData(dynamic_cast<AudioData*>(fileData));
	if (!audioData.get())
	{
		error.Add("Expected to get audio data from file (" + inFilePath + "), but didn't");
		delete fileData;
		return false;
	}

	if (audioData->GetFormat().numChannels == 0)
	{
		error.Add("No channels!");
		return false;
	}

	// TODO: I'm pretty sure this will NOT sound correct for anything other than mono based on my expiraments to-date.
	std::vector<std::shared_ptr<SynthModule>> synthModuleArray;
	for (uint16_t i = 0; i < audioData->GetFormat().numChannels; i++)
	{
		auto loopedAudioModule = new LoopedAudioModule();
		auto reverbModule = new ReverbModule(0);
		reverbModule->SetEnabled(true);
		reverbModule->AddDependentModule(std::shared_ptr<SynthModule>(loopedAudioModule));
		synthModuleArray.push_back(std::shared_ptr<SynthModule>(reverbModule));
		if (!loopedAudioModule->UseNonLoopedAudioData(audioData.get(), i, error))
			return false;
	}

	std::shared_ptr<AudioStream> reverbStream(new AudioStream());
	reverbStream->SetFormat(audioData->GetFormat());

	// TODO: When I shrink this time window to 0.005, I get some audible artifacting.  Why?
	double timeChunkSeconds = 0.5;
	uint64_t reverbAudioBufferSize = audioData->GetFormat().BytesFromSeconds(timeChunkSeconds);
	uint8_t* reverbAudioBuffer = new uint8_t[reverbAudioBufferSize];
	::memset(reverbAudioBuffer, 0, reverbAudioBufferSize);

	while (true)
	{
		bool moreSoundAvailable = false;
		for (std::shared_ptr<SynthModule>& synthModule : synthModuleArray)
		{
			if (synthModule->MoreSoundAvailable())
			{
				moreSoundAvailable = true;
				break;
			}
		}

		if (!moreSoundAvailable)
			break;

		for (uint16_t i = 0; i < audioData->GetFormat().numChannels; i++)
		{
			SynthModule* synthModule = synthModuleArray[i].get();

			WaveForm waveForm;
			if (!synthModule->GenerateSound(timeChunkSeconds, audioData->GetFormat().framesPerSecond, waveForm, nullptr, error))
				break;

			if (!waveForm.ConvertToAudioBuffer(audioData->GetFormat(), reverbAudioBuffer, reverbAudioBufferSize, i, error))
				break;
		}
		
		if (!error)
			reverbStream->WriteBytesToStream(reverbAudioBuffer, reverbAudioBufferSize);
		else
			break;
	}

	delete[] reverbAudioBuffer;

	if (error)
		return false;

	std::shared_ptr<AudioData> reverbAudioData(new AudioData());
	reverbAudioData->SetFormat(audioData->GetFormat());
	reverbAudioData->SetAudioBufferSize(reverbStream->GetSize());
	reverbStream->ReadBytesFromStream(reverbAudioData->GetAudioBuffer(), reverbStream->GetSize());

	FileOutputStream outputStream(outFilePath.c_str());
	if (!outputStream.IsOpen())
	{
		error.Add("Failed to open file: " + outFilePath);
		return false;
	}

	if (!fileFormat->WriteToStream(outputStream, reverbAudioData.get(), error))
	{
		error.Add("Failed to write file: " + outFilePath);
		return false;
	}

	return true;
}

bool PlayWithKeyboard(CmdLineParser& parser, AudioDataLib::Error& error)
{
	bool success = false;
	MidiData* recordedMidiData = nullptr;
	FileOutputStream* recordedMidiOutStream = nullptr;
	MidiMsgSource* source = nullptr;
	std::string recordedMidiFilePath;
	std::string recordedWaveFilePath;
	Keyboard* keyboard = nullptr;
	SDLAudio* player = nullptr;
	std::shared_ptr<AudioStream> recordedAudioStream;

	do
	{
		// No, this isn't the keyboard we're playing with.
		// This is the computer keyboard that we'll need to exit our processing loop.
		// We're not necessarily playing with a MIDI keyboard here.  We're playing
		// with any MIDI input device.
		keyboard = Keyboard::Create();
		if (!keyboard)
		{
			error.Add("Failed to create keyboard object.");
			break;
		}

		std::string keyboardError;
		if (!keyboard->Setup(keyboardError))
		{
			error.Add(keyboardError);
			break;
		}

		std::string desiredPortName = parser.GetArgValue("keyboard", 0);
		if (desiredPortName == "debug")
			source = new MidiDebugSource();	// TODO: This doesn't yet work.  Too lazy to make it work right now.
		else
			source = new MidiPortSource(desiredPortName);

		if (parser.ArgGiven("log_midi"))
		{
			class StdoutLogDestination : public MidiMsgLogDestination
			{
			public:
				virtual void LogMessage(const std::string& logMessage) override
				{
					printf("MIDI LOG: %s\n", logMessage.c_str());
				}
			};

			source->AddDestination(std::shared_ptr<MidiMsgDestination>(new StdoutLogDestination()));
		}

		if (parser.ArgGiven("record_midi"))
		{
			recordedMidiFilePath = parser.GetArgValue("record_midi", 0);
			if (recordedMidiFilePath.length() == 0)
			{
				error.Add("No MIDI file path given for recorded MIDI output.");
				break;
			}

			recordedMidiOutStream = new FileOutputStream(recordedMidiFilePath.c_str());
			if (!recordedMidiOutStream->IsOpen())
			{
				error.Add(FormatString("Failed to open file %s for writing.", recordedMidiFilePath.c_str()));
				break;
			}

			recordedMidiData = new MidiData();
			auto recorderDestination = new MidiMsgRecorderDestination();
			recorderDestination->SetMidiData(recordedMidiData);
			source->AddDestination(std::shared_ptr<MidiMsgDestination>(recorderDestination));
		}

		if (parser.ArgGiven("synth"))
		{
			std::string synthType = parser.GetArgValue("synth", 0);

			MidiSynth* midiSynth = nullptr;

			if (synthType == "simple")
			{
				auto simpleSynth = new SimpleSynth();
				source->AddDestination(std::shared_ptr<MidiMsgDestination>(simpleSynth));
				midiSynth = simpleSynth;
			}
			else if (synthType == "sample")
			{
				auto sampleBasedSynth = new SampleBasedSynth();
				source->AddDestination(std::shared_ptr<MidiMsgDestination>(sampleBasedSynth));
				midiSynth = sampleBasedSynth;

				if (!parser.ArgGiven("soundfont"))
				{
					error.Add("Can't use \"sample\" synth type unless you also specify at least one sound-font.");
					break;
				}

				int i = 0;
				while (true)
				{
					std::string instrumentNumberStr = parser.GetArgValue("soundfont", 0, i);
					if (instrumentNumberStr.length() == 0)
						break;

					uint16_t instrumentNumber = ::atoi(instrumentNumberStr.c_str());

					std::string soundFontFile = parser.GetArgValue("soundfont", 1, i);
					FileInputStream inputStream(soundFontFile.c_str());
					SoundFontFormat soundFontFormat;

					FileData* fileData = nullptr;
					if (!soundFontFormat.ReadFromStream(inputStream, fileData, error))
					{
						error.Add("Failed to read file: " + soundFontFile);
						break;
					}

					std::shared_ptr<SoundFontData> soundFontData(dynamic_cast<SoundFontData*>(fileData));
					if (!soundFontData)
					{
						error.Add("Expected sound font data; got something else!");
						delete fileData;
						break;
					}
					
					// TODO: One problem with this is that I'm assuming there's just one instrument per sound-font,
					//       and I don't think that's generally the case.  You can have multiple instruments in a
					//       single sound-font file.
					if (!sampleBasedSynth->SetSoundFontData(instrumentNumber, soundFontData, false, error))
						break;

					i++;

					if (i <= 16)
						if (!sampleBasedSynth->SetChannelInstrument(i, instrumentNumber, error))
							break;
				}

				if (error)
					break;
			}

			if (!midiSynth)
			{
				error.Add("Did not recognize: " + synthType);
				break;
			}

			std::shared_ptr<Mutex> mutex(new StandardMutex());
			std::shared_ptr<AudioStream> audioStream(new ThreadSafeAudioStream(mutex));
			midiSynth->SetAudioStream(audioStream);

			player = new SDLAudio(SDLAudio::AudioDirection::SOUND_OUT);
			player->SetAudioStream(midiSynth->GetAudioStream());

			if (parser.ArgGiven("record_wave"))
			{
				recordedWaveFilePath = parser.GetArgValue("record_wave", 0);
				if (recordedWaveFilePath.length() == 0)
				{
					error.Add("No WAVE file path given for recorded WAVE output.");
					break;
				}

				if (!player)
				{
					error.Add("No audio player with which to capture WAV data!");
					break;
				}

				recordedAudioStream = std::shared_ptr<AudioStream>(new AudioStream());
				player->SetRecordedAudioStream(recordedAudioStream);
			}

			std::string deviceSubStr;
			if (parser.ArgGiven("device_substr"))
				deviceSubStr = parser.GetArgValue("device_substr", 0);

			if (!player->Setup(deviceSubStr, error))
			{
				error.Add("Failed to setup SDL audio player!");
				break;
			}
		}

		if (!source->Setup(error))
		{
			error.Add("MIDI input setup failed.");
			break;
		}

		printf("Now listening to MIDI port...  (Press ESCAPE to exit.)\n");

		bool keepProcessing = true;
		while (keepProcessing)
		{
			if (!source->Process(error))
			{
				error.Add(FormatString("Process error: %s\n", error.GetErrorMessage().c_str()));
				break;
			}

			std::string keyboardError;
			keyboard->Process(keyboardError);

			Keyboard::Event event;
			while (keyboard->GetKeyboardEvent(event))
			{
				if (event.type == Keyboard::Event::Type::KEY_RELEASED)
				{
					switch (event.keyCode)
					{
						case int32_t(Keyboard::Key::KEY_ESCAPE):
						{
							keepProcessing = false;
							break;
						}
						case 'R':
						case 'r':
						{
							SampleBasedSynth* synth = source->FindDestination<SampleBasedSynth>();
							if (synth)
							{
								bool enabled = !synth->GetReverbEnabled();
								synth->SetReverbEnabled(enabled);
								printf("Reverb %s\n", (enabled ? "ON" : "OFF"));
							}
							break;
						}
					}
				}
			}
		}

		if (error)
			break;

		success = true;
	} while (false);

	if (keyboard)
	{
		std::string keyboardError;
		keyboard->Shutdown(keyboardError);
		delete keyboard;
		keyboard = nullptr;
	}

	// Must shutdown the player before the synth so that the
	// player doesn't get caught with a stale pointer.  Yes,
	// I should probably be using shared pointers and the like.
	if (player)
	{
		player->Shutdown(error);
		delete player;
		player = nullptr;
	}

	if (source)
	{
		source->Shutdown(error);
		delete source;
		source = nullptr;
	}

	if (recordedAudioStream.get())
	{
		AudioData audioData;
		audioData.SetAudioBufferSize(recordedAudioStream->GetSize());
		audioData.SetFormat(recordedAudioStream->GetFormat());
		recordedAudioStream->ReadBytesFromStream(audioData.GetAudioBuffer(), audioData.GetAudioBufferSize());
		FileOutputStream recordedWaveOutputStream(recordedWaveFilePath.c_str());
		WaveFileFormat fileFormat;
		fileFormat.WriteToStream(recordedWaveOutputStream, &audioData, error);
	}

	if (recordedMidiData)
	{
		if (!recordedMidiOutStream->IsOpen())
		{
			error.Add("Output file stream was open before the performance started, but is not open now?!");
			success = false;
		}
		else
		{
			MidiFileFormat fileFormat;
			if (fileFormat.WriteToStream(*recordedMidiOutStream, recordedMidiData, error))
				printf("Saved files: %s!\n", recordedMidiFilePath.c_str());
			else
			{
				error.Add("Failed to write recording to the file output stream.");
				success = false;
			}
		}

		delete recordedMidiData;
		delete recordedMidiOutStream;
	}

	if (error)
		success = false;

	return success;
}

bool PlayMidiData(AudioDataLib::MidiData* midiData, AudioDataLib::Error& error)
{
	bool success = false;
	SystemClockTimer timer;
	MidiPlayer player(&timer, nullptr);
	Keyboard* keyboard = nullptr;
	std::string keyboardError;

	do
	{
		keyboard = Keyboard::Create();
		if (!keyboard)
		{
			error.Add("Could not create keyboard!");
			break;
		}

		if (!keyboard->Setup(keyboardError))
		{
			error.Add(keyboardError);
			break;
		}

		player.AddDestination(std::shared_ptr<MidiMsgDestination>(new MidiPortDestination()));
		player.SetMidiData(midiData);
		player.ConfigureToPlayAllTracks();
		player.SetTimeSeconds(0.0);
		if (!player.Setup(error))
			break;

		printf("MIDI file should be playing now... (Press ESCAPE to exit prematurely.\n");

		while (!player.NoMoreToPlay())
		{
			if (!player.Process(error))
				break;

			if (!keyboard->Process(keyboardError))
			{
				error.Add(keyboardError);
				break;
			}

			Keyboard::Event event;
			if (keyboard->GetKeyboardEvent(event))
				if (event.type == Keyboard::Event::Type::KEY_PRESSED && event.keyCode == (int32_t)Keyboard::Key::KEY_ESCAPE)
					break;
		}

		if (error)
			break;

		if (!player.Shutdown(error))
			break;

		success = true;
	} while (false);

	if (keyboard)
	{
		keyboard->Shutdown(keyboardError);
		delete keyboard;
	}

	return success;
}

bool PlayAudioData(AudioDataLib::AudioData* audioData, CmdLineParser& parser, AudioDataLib::Error& error)
{
	bool success = false;
	SDLAudio player(SDLAudio::AudioDirection::SOUND_OUT);
	AudioSink audioSink(true, true);
	Keyboard* keyboard = nullptr;
	std::string keyboardError;

	do
	{
		keyboard = Keyboard::Create();
		if (!keyboard)
		{
			error.Add("Failed to create keyboard interface.");
			break;
		}

		if (!keyboard->Setup(keyboardError))
		{
			error.Add(keyboardError);
			break;
		}

		std::shared_ptr<Mutex> mutex(new StandardMutex());
		std::shared_ptr<AudioStream> audioStreamOut(new ThreadSafeAudioStream(mutex));
		audioSink.SetAudioOutput(audioStreamOut);

		player.SetAudioStream(audioSink.GetAudioOutput());

		std::string deviceSubStr;
		if (parser.ArgGiven("device_substr"))
			deviceSubStr = parser.GetArgValue("device_substr", 0);

		if (!player.Setup(deviceSubStr, error))
		{
			error.Add("Failed to setup player.");
			break;
		}

		std::shared_ptr<AudioStream> audioStreamIn(new AudioStream(audioData));
		audioSink.AddAudioInput(audioStreamIn);

		printf("Sound should be playing... (Press ESCAPE to exit before the audio finishes.)\n");

		while (audioSink.GetAudioInputCount() > 0)
		{
			audioSink.GenerateAudio(0.2, 0.1);

			std::string keyboardError;
			if (!keyboard->Process(keyboardError))
			{
				error.Add(keyboardError);
				break;
			}

			Keyboard::Event event;
			if (keyboard->GetKeyboardEvent(event))
				if (event.type == Keyboard::Event::Type::KEY_PRESSED && event.keyCode == (int32_t)Keyboard::Key::KEY_ESCAPE)
					break;
		}

		if (error)
			break;

		success = true;
	} while (false);
	
	player.Shutdown(error);

	if (keyboard)
	{
		keyboard->Shutdown(keyboardError);
		delete keyboard;
	}

	return success;
}

bool MixAudio(const std::vector<std::string>& sourceFileArray, const std::string& destinationFile, AudioDataLib::Error& error)
{
	std::vector<std::shared_ptr<FileFormat>> fileFormatArray;
	std::vector<std::shared_ptr<AudioData>> audioDataArray;

	for (const std::string& sourceFile : sourceFileArray)
	{
		std::shared_ptr<FileFormat> fileFormat = FileFormat::CreateForFile(sourceFile);
		if (!fileFormat.get())
		{
			error.Add("Did not recognize file type for file: " + sourceFile);
			return false;
		}

		fileFormatArray.push_back(fileFormat);
	}

	if (fileFormatArray.size() != sourceFileArray.size())
	{
		error.Add("Could not recognize all source file type.");
		return false;
	}

	for (int i = 0; i < (signed)sourceFileArray.size(); i++)
	{
		FileFormat* fileFormat = fileFormatArray[i].get();
		const std::string& sourceFile = sourceFileArray[i];

		FileInputStream inputStream(sourceFile.c_str());
		if (!inputStream.IsOpen())
		{
			error.Add(FormatString("Failed to open file %s for reading.", sourceFile.c_str()));
			return false;
		}

		FileData* fileData = nullptr;
		if (!fileFormat->ReadFromStream(inputStream, fileData, error))
		{
			error.Add("Failed to read file: " + sourceFile);
			return false;
		}

		std::shared_ptr<AudioData> audioData(dynamic_cast<AudioData*>(fileData));
		if (!audioData.get())
		{
			error.Add(FormatString("File data for file %s is not audio data.", sourceFile.c_str()));
			delete fileData;
			return false;
		}

		audioDataArray.push_back(audioData);
	}

	if (audioDataArray.size() != sourceFileArray.size())
	{
		error.Add("Could not load all source files.");
		return false;
	}

	AudioSink audioSink(true, true);

	AudioData::Format format;
	format.bitsPerSample = 0;

	double maxTimeSeconds = 0.0;
	for (std::shared_ptr<AudioData>& audioData : audioDataArray)
	{
		double timeSeconds = audioData->GetTimeSeconds();
		if (maxTimeSeconds < timeSeconds)
			maxTimeSeconds = timeSeconds;

		std::shared_ptr<AudioStream> audioStreamIn(new AudioStream(audioData.get()));
		audioSink.AddAudioInput(audioStreamIn);

		if (format.bitsPerSample == 0)
			format = audioData->GetFormat();
	}

	std::shared_ptr<AudioStream> audioStreamOut(new AudioStream());
	audioStreamOut->SetFormat(format);
	audioSink.SetAudioOutput(audioStreamOut);
	audioSink.GenerateAudio(maxTimeSeconds, 0.0);

	AudioData generatedAudioData;
	generatedAudioData.GetFormat() = audioStreamOut->GetFormat();
	generatedAudioData.SetAudioBufferSize(audioStreamOut->GetSize());
	audioStreamOut->ReadBytesFromStream(generatedAudioData.GetAudioBuffer(), generatedAudioData.GetAudioBufferSize());

	std::shared_ptr<FileFormat> fileFormatOut = FileFormat::CreateForFile(destinationFile);
	if (!fileFormatOut.get())
	{
		error.Add("Could not recognize file type for file: " + destinationFile);
		return false;
	}

	FileOutputStream outputStream(destinationFile.c_str());
	if (!outputStream.IsOpen())
	{
		error.Add(FormatString("Could not open file %s for writing.", destinationFile.c_str()));
		return false;
	}

	if (!fileFormatOut->WriteToStream(outputStream, &generatedAudioData, error))
	{
		error.Add("Failed to write file: " + destinationFile);
		return false;
	}

	return true;
}

bool DumpInfo(const std::string& filePath, bool csv, AudioDataLib::Error& error)
{
	bool success = false;
	
	FileInputStream inputStream(filePath.c_str());
	if (!inputStream.IsOpen())
	{
		error.Add("Failed to open file: " + filePath);
		return false;
	}

	std::shared_ptr<FileFormat> fileFormat = FileFormat::CreateForFile(filePath.c_str());
	if (!fileFormat.get())
	{
		error.Add("Failed type not recognized for file: " + filePath);
		return false;
	}

	FileData* fileData = nullptr;
	if (!fileFormat->ReadFromStream(inputStream, fileData, error))
	{
		error.Add("Failed to read file: " + filePath);
		return false;
	}

	if (csv)
		fileData->DumpCSV(stdout);
	else
		fileData->DumpInfo(stdout);

	delete fileData;

	return true;
}

bool UnpackSoundFont(const std::string& filePath, AudioDataLib::Error& error)
{
	bool success = false;
	
	std::shared_ptr<FileFormat> fileFormat = FileFormat::CreateForFile(filePath);
	if (!fileFormat)
	{
		error.Add("Could not recognize file type: " + filePath);
		return false;
	}

	auto soundFontFormat = dynamic_cast<SoundFontFormat*>(fileFormat.get());
	if (!soundFontFormat)
	{
		error.Add("Not given a sound-font file: " + filePath);
		return false;
	}

	FileInputStream inputStream(filePath.c_str());
	if (!inputStream.IsOpen())
	{
		error.Add("Failed to open file: " + filePath);
		return false;
	}

	FileData* fileData = nullptr;
	if (!soundFontFormat->ReadFromStream(inputStream, fileData, error))
	{
		error.Add("Failed to read file: " + filePath);
		return false;
	}

	std::shared_ptr<SoundFontData> soundFontData(dynamic_cast<SoundFontData*>(fileData));
	if (!soundFontData.get())
	{
		error.Add("Didn't get sound font data!");
		return false;
	}

	if (soundFontData->GetNumAudioSamples() == 0)
	{
		error.Add("No audio samples found in the sound font data!");
		return false;
	}

	WaveFileFormat waveFileFormat;

	for (uint32_t i = 0; i < soundFontData->GetNumAudioSamples(); i++)
	{
		const SoundFontData::AudioSample* audioSample = soundFontData->GetAudioSample(i);
			
		for (uint32_t j = 0; j < audioSample->GetNumAudioDatas(); j++)
		{
			auto audioData = dynamic_cast<const SoundFontData::LoopedAudioData*>(audioSample->GetAudioData(j));
			if (!audioData)
			{
				error.Add(FormatString("Sample %d is not looped audio data.", i));
				return false;
			}

			std::string sampleFilePath = (std::filesystem::path(filePath).parent_path() / std::filesystem::path(filePath).stem()).string();
			sampleFilePath += "__" + audioData->GetName();
			sampleFilePath += ".wav";

			std::replace(sampleFilePath.begin(), sampleFilePath.end(), ' ', '_');
			std::replace(sampleFilePath.begin(), sampleFilePath.end(), '|', '_');
			std::replace(sampleFilePath.begin(), sampleFilePath.end(), '(', '_');
			std::replace(sampleFilePath.begin(), sampleFilePath.end(), ')', '_');
			std::replace(sampleFilePath.begin(), sampleFilePath.end(), '#', 's');

			FileOutputStream outputStream(sampleFilePath.c_str());
			if (!outputStream.IsOpen())
			{
				error.Add(FormatString("Failed to open file %s for writing.", sampleFilePath.c_str()));
				return false;
			}

			if (!waveFileFormat.WriteToStream(outputStream, audioData, error))
				return false;
		}
	}

	return true;
}